"""
[UNICODE_30D5]
[UNICODE_03B1]
"""
import re
import json
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime, timedelta
from enum import Enum
from pydantic import BaseModel, Field
from collections import Counter, defaultdict
import statistics
import logging
import asyncio
from dataclasses import dataclass

logger = logging.getLogger(__name__)

class FeedbackCategory(Enum):
    """[UNICODE_30D5]"""
    BUG_REPORT = "bug_report"
    FEATURE_REQUEST = "feature_request"
    USABILITY = "usability"
    THERAPEUTIC_EFFECT = "therapeutic_effect"
    PERFORMANCE = "performance"
    ACCESSIBILITY = "accessibility"
    CONTENT = "content"
    GENERAL = "general"

class FeedbackPriority(Enum):
    """[UNICODE_30D5]"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class SentimentType(Enum):
    """[UNICODE_611F]"""
    VERY_NEGATIVE = "very_negative"
    NEGATIVE = "negative"
    NEUTRAL = "neutral"
    POSITIVE = "positive"
    VERY_POSITIVE = "very_positive"

@dataclass
class ThemeAnalysis:
    """[UNICODE_30C6]"""
    theme: str
    frequency: int
    sentiment_score: float
    related_keywords: List[str]
    user_count: int

@dataclass
class SentimentAnalysis:
    """[UNICODE_611F]"""
    overall_score: float
    sentiment_type: SentimentType
    confidence: float
    positive_keywords: List[str]
    negative_keywords: List[str]

class FeedbackItem(BaseModel):
    """[UNICODE_30D5]"""
    feedback_id: str = Field(default_factory=lambda: f"fb_{datetime.now().strftime('%Y%m%d_%H%M%S')}")
    user_id: str
    category: FeedbackCategory
    title: str
    content: str
    rating: Optional[int] = Field(None, ge=1, le=5)
    priority: FeedbackPriority = FeedbackPriority.MEDIUM
    created_at: datetime = Field(default_factory=datetime.now)
    updated_at: datetime = Field(default_factory=datetime.now)
    
    # [UNICODE_5206]
    sentiment_analysis: Optional[SentimentAnalysis] = None
    themes: List[str] = Field(default_factory=list)
    keywords: List[str] = Field(default_factory=list)
    
    # [UNICODE_51E6]
    processed: bool = False
    assigned_to: Optional[str] = None
    status: str = "open"  # open, in_progress, resolved, closed
    resolution: Optional[str] = None
    
    # [UNICODE_30E1]
    device_info: Optional[Dict[str, Any]] = None
    app_version: Optional[str] = None
    user_context: Optional[Dict[str, Any]] = None

class FeedbackAnalysisEngine:
    """[UNICODE_30D5]"""
    
    def __init__(self):
        self.feedback_items: List[FeedbackItem] = []
        self.theme_patterns = self._initialize_theme_patterns()
        self.sentiment_keywords = self._initialize_sentiment_keywords()
        self.improvement_templates = self._initialize_improvement_templates()
        
    def _initialize_theme_patterns(self) -> Dict[str, List[str]]:
        """[UNICODE_30C6]"""
        return {
            "ui_navigation": [
                r"[UNICODE_30CA]", r"[UNICODE_30E1]", r"[UNICODE_753B]", r"[UNICODE_623B]", r"[UNICODE_9032]",
                r"[UNICODE_30BF]", r"[UNICODE_30DC]", r"[UNICODE_30EA]", r"[UNICODE_64CD]", r"[UNICODE_4F7F]"
            ],
            "performance": [
                r"[UNICODE_9045]", r"[UNICODE_91CD]", r"[UNICODE_30D5]", r"[UNICODE_56FA]", r"[UNICODE_5FDC]", r"[UNICODE_8AAD]",
                r"[UNICODE_30AF]", r"[UNICODE_843D]", r"[UNICODE_52D5]", r"[UNICODE_901F]"
            ],
            "therapeutic_effectiveness": [
                r"[UNICODE_52B9]", r"[UNICODE_6539]", r"[UNICODE_6C17]", r"[UNICODE_30E2]", r"[UNICODE_3084]",
                r"[UNICODE_7FD2]", r"[UNICODE_7D99]", r"[UNICODE_6CBB]", r"[UNICODE_56DE]", r"[UNICODE_6210]"
            ],
            "gamification": [
                r"[UNICODE_30B2]", r"[UNICODE_30EC]", r"XP", r"[UNICODE_30DD]", r"[UNICODE_5831]", r"[UNICODE_9054]",
                r"[UNICODE_30D0]", r"[UNICODE_30E9]", r"[UNICODE_7AF6]", r"[UNICODE_697D]"
            ],
            "accessibility": [
                r"[UNICODE_898B]", r"[UNICODE_8AAD]", r"[UNICODE_6587]", r"[UNICODE_8272]", r"[UNICODE_30B3]",
                r"[UNICODE_30D5]", r"[UNICODE_30B5]", r"[UNICODE_30A2]", r"[UNICODE_969C]"
            ],
            "content_quality": [
                r"[UNICODE_5185]", r"[UNICODE_30B3]", r"[UNICODE_30B9]", r"[UNICODE_6587]", r"[UNICODE_8AAC]",
                r"[UNICODE_5206]", r"[UNICODE_5206]", r"[UNICODE_7406]", r"[UNICODE_60C5]"
            ],
            "mobile_experience": [
                r"[UNICODE_30B9]", r"[UNICODE_30E2]", r"[UNICODE_30BF]", r"[UNICODE_30B9]", r"[UNICODE_753B]",
                r"[UNICODE_30B5]", r"[UNICODE_30EC]", r"[UNICODE_7E26]", r"[UNICODE_6A2A]"
            ],
            "data_privacy": [
                r"[UNICODE_30D7]", r"[UNICODE_500B]", r"[UNICODE_30C7]", r"[UNICODE_5B89]", r"[UNICODE_30BB]",
                r"[UNICODE_540C]", r"[UNICODE_524A]", r"[UNICODE_5171]"
            ]
        }
    
    def _initialize_sentiment_keywords(self) -> Dict[str, List[str]]:
        """[UNICODE_611F]"""
        return {
            "very_positive": [
                "[UNICODE_7D20]", "[UNICODE_6700]", "[UNICODE_5B8C]", "[UNICODE_611F]", "[UNICODE_9A5A]", "[UNICODE_9769]",
                "[UNICODE_753B]", "[UNICODE_512A]", "[UNICODE_5353]", "[UNICODE_5091]"
            ],
            "positive": [
                "[UNICODE_826F]", "[UNICODE_3044]", "[UNICODE_4FBF]", "[UNICODE_4F7F]", "[UNICODE_6E80]", "[UNICODE_5FEB]",
                "[UNICODE_52B9]", "[UNICODE_5F79]", "[UNICODE_6539]", "[UNICODE_5411]", "[UNICODE_697D]", "[UNICODE_9762]"
            ],
            "negative": [
                "[UNICODE_60AA]", "[UNICODE_3060]", "[UNICODE_56F0]", "[UNICODE_4E0D]", "[UNICODE_4F7F]", "[UNICODE_4E0D]",
                "[UNICODE_554F]", "[UNICODE_30A8]", "[UNICODE_30D0]", "[UNICODE_9045]", "[UNICODE_91CD]", "[UNICODE_5206]"
            ],
            "very_negative": [
                "[UNICODE_6700]", "[UNICODE_3072]", "[UNICODE_4F7F]", "[UNICODE_30AF]", "[UNICODE_58CA]",
                "[UNICODE_5931]", "[UNICODE_6012]", "[UNICODE_30A4]", "[UNICODE_30B9]", "[UNICODE_8AE6]"
            ]
        }
    
    def _initialize_improvement_templates(self) -> Dict[str, List[str]]:
        """[UNICODE_6539]"""
        return {
            "ui_navigation": [
                "[UNICODE_30CA]",
                "[UNICODE_30E1]",
                "[UNICODE_30E6]",
                "[UNICODE_64CD]"
            ],
            "performance": [
                "[UNICODE_30D1]",
                "[UNICODE_8AAD]",
                "[UNICODE_30E1]",
                "[UNICODE_30EC]"
            ],
            "therapeutic_effectiveness": [
                "[UNICODE_6CBB]",
                "[UNICODE_30E6]",
                "[UNICODE_30E2]",
                "[UNICODE_500B]"
            ],
            "accessibility": [
                "[UNICODE_30A2]",
                "[UNICODE_8996]",
                "[UNICODE_64CD]",
                "[UNICODE_591A]"
            ]
        }
    
    async def submit_feedback(self, user_id: str, category: FeedbackCategory,
                            title: str, content: str, rating: Optional[int] = None,
                            device_info: Optional[Dict] = None,
                            app_version: Optional[str] = None) -> FeedbackItem:
        """[UNICODE_30D5]"""
        
        feedback = FeedbackItem(
            user_id=user_id,
            category=category,
            title=title,
            content=content,
            rating=rating,
            device_info=device_info,
            app_version=app_version
        )
        
        # [UNICODE_81EA]
        await self._analyze_feedback(feedback)
        
        # [UNICODE_512A]
        feedback.priority = self._determine_priority(feedback)
        
        self.feedback_items.append(feedback)
        
        logger.info(f"Feedback submitted: {feedback.feedback_id} by {user_id}")
        return feedback
    
    async def _analyze_feedback(self, feedback: FeedbackItem):
        """[UNICODE_30D5]"""
        
        # [UNICODE_611F]
        feedback.sentiment_analysis = await self._perform_sentiment_analysis(feedback.content)
        
        # [UNICODE_30C6]
        feedback.themes = await self._extract_themes(feedback.content, feedback.category)
        
        # [UNICODE_30AD]
        feedback.keywords = await self._extract_keywords(feedback.content)
        
        feedback.processed = True
        feedback.updated_at = datetime.now()
    
    async def _perform_sentiment_analysis(self, text: str) -> SentimentAnalysis:
        """[UNICODE_611F]"""
        text_lower = text.lower()
        
        # [UNICODE_30AD]
        sentiment_scores = {
            "very_positive": 2,
            "positive": 1,
            "negative": -1,
            "very_negative": -2
        }
        
        total_score = 0
        total_words = 0
        positive_keywords = []
        negative_keywords = []
        
        for sentiment_type, keywords in self.sentiment_keywords.items():
            for keyword in keywords:
                if keyword in text_lower:
                    total_score += sentiment_scores[sentiment_type]
                    total_words += 1
                    
                    if sentiment_scores[sentiment_type] > 0:
                        positive_keywords.append(keyword)
                    else:
                        negative_keywords.append(keyword)
        
        # [UNICODE_6B63]-1[UNICODE_304B]1[UNICODE_306E]
        normalized_score = total_score / max(total_words, 1) if total_words > 0 else 0
        normalized_score = max(-1, min(1, normalized_score))
        
        # [UNICODE_611F]
        if normalized_score >= 0.6:
            sentiment_type = SentimentType.VERY_POSITIVE
        elif normalized_score >= 0.2:
            sentiment_type = SentimentType.POSITIVE
        elif normalized_score <= -0.6:
            sentiment_type = SentimentType.VERY_NEGATIVE
        elif normalized_score <= -0.2:
            sentiment_type = SentimentType.NEGATIVE
        else:
            sentiment_type = SentimentType.NEUTRAL
        
        # [UNICODE_4FE1]
        confidence = min(1.0, total_words / 5)  # 5[UNICODE_500B]
        
        return SentimentAnalysis(
            overall_score=normalized_score,
            sentiment_type=sentiment_type,
            confidence=confidence,
            positive_keywords=positive_keywords,
            negative_keywords=negative_keywords
        )
    
    async def _extract_themes(self, text: str, category: FeedbackCategory) -> List[str]:
        """[UNICODE_30C6]"""
        text_lower = text.lower()
        detected_themes = []
        
        for theme, patterns in self.theme_patterns.items():
            for pattern in patterns:
                if re.search(pattern, text_lower):
                    detected_themes.append(theme)
                    break
        
        # [UNICODE_30AB]
        category_themes = {
            FeedbackCategory.BUG_REPORT: ["bug_report"],
            FeedbackCategory.FEATURE_REQUEST: ["feature_request"],
            FeedbackCategory.USABILITY: ["ui_navigation"],
            FeedbackCategory.THERAPEUTIC_EFFECT: ["therapeutic_effectiveness"],
            FeedbackCategory.PERFORMANCE: ["performance"],
            FeedbackCategory.ACCESSIBILITY: ["accessibility"]
        }
        
        if category in category_themes:
            detected_themes.extend(category_themes[category])
        
        return list(set(detected_themes))  # [UNICODE_91CD]
    
    async def _extract_keywords(self, text: str) -> List[str]:
        """[UNICODE_30AD]"""
        # [UNICODE_7C21]
        
        # [UNICODE_30B9]
        stop_words = {
            "[UNICODE_306E]", "[UNICODE_306B]", "[UNICODE_306F]", "[UNICODE_3092]", "[UNICODE_304C]", "[UNICODE_3067]", "[UNICODE_3068]", "[UNICODE_304B]", "[UNICODE_307E]",
            "[UNICODE_3067]", "[UNICODE_3067]", "[UNICODE_3060]", "[UNICODE_3067]", "[UNICODE_307E]", "[UNICODE_3057]", "[UNICODE_3059]",
            "[UNICODE_3053]", "[UNICODE_305D]", "[UNICODE_3042]", "[UNICODE_3053]", "[UNICODE_305D]", "[UNICODE_3042]"
        }
        
        # [UNICODE_5358]
        words = re.findall(r'[[UNICODE_3041]-[UNICODE_3093]-[UNICODE_30F6]-[UNICODE_9FA0]a-zA-Z0-9]+', text)
        
        # [UNICODE_30D5]
        keywords = [
            word for word in words
            if len(word) >= 2 and word not in stop_words
        ]
        
        # [UNICODE_983B]
        word_counts = Counter(keywords)
        return [word for word, count in word_counts.most_common(10)]
    
    def _determine_priority(self, feedback: FeedbackItem) -> FeedbackPriority:
        """[UNICODE_512A]"""
        
        # [UNICODE_30AF]
        critical_keywords = ["[UNICODE_30AF]", "[UNICODE_843D]", "[UNICODE_4F7F]", "[UNICODE_30C7]", "[UNICODE_30BB]"]
        if any(keyword in feedback.content for keyword in critical_keywords):
            return FeedbackPriority.CRITICAL
        
        # [UNICODE_9AD8]
        if (feedback.category == FeedbackCategory.BUG_REPORT or
            feedback.rating and feedback.rating <= 2 or
            feedback.sentiment_analysis and feedback.sentiment_analysis.overall_score <= -0.5):
            return FeedbackPriority.HIGH
        
        # [UNICODE_4E2D]
        if (feedback.category in [FeedbackCategory.USABILITY, FeedbackCategory.PERFORMANCE] and
            feedback.rating and feedback.rating == 3):
            return FeedbackPriority.MEDIUM
        
        # [UNICODE_6A5F]
        if feedback.category == FeedbackCategory.FEATURE_REQUEST:
            return FeedbackPriority.MEDIUM
        
        # [UNICODE_30DD]4[UNICODE_4EE5]
        if feedback.rating and feedback.rating >= 4:
            return FeedbackPriority.LOW
        
        return FeedbackPriority.MEDIUM  # [UNICODE_30C7]
    
    async def generate_theme_analysis(self, days: int = 30) -> List[ThemeAnalysis]:
        """[UNICODE_30C6]"""
        cutoff_date = datetime.now() - timedelta(days=days)
        recent_feedback = [
            fb for fb in self.feedback_items
            if fb.created_at >= cutoff_date
        ]
        
        # [UNICODE_30C6]
        theme_stats = defaultdict(lambda: {
            "frequency": 0,
            "sentiment_scores": [],
            "keywords": [],
            "users": set()
        })
        
        for feedback in recent_feedback:
            for theme in feedback.themes:
                stats = theme_stats[theme]
                stats["frequency"] += 1
                stats["users"].add(feedback.user_id)
                stats["keywords"].extend(feedback.keywords)
                
                if feedback.sentiment_analysis:
                    stats["sentiment_scores"].append(feedback.sentiment_analysis.overall_score)
        
        # [UNICODE_5206]
        theme_analyses = []
        for theme, stats in theme_stats.items():
            avg_sentiment = statistics.mean(stats["sentiment_scores"]) if stats["sentiment_scores"] else 0
            
            # [UNICODE_95A2]
            keyword_counts = Counter(stats["keywords"])
            related_keywords = [kw for kw, count in keyword_counts.most_common(5)]
            
            analysis = ThemeAnalysis(
                theme=theme,
                frequency=stats["frequency"],
                sentiment_score=avg_sentiment,
                related_keywords=related_keywords,
                user_count=len(stats["users"])
            )
            theme_analyses.append(analysis)
        
        # [UNICODE_983B]
        theme_analyses.sort(key=lambda x: x.frequency, reverse=True)
        return theme_analyses
    
    async def generate_improvement_suggestions(self, theme_analyses: List[ThemeAnalysis]) -> List[Dict[str, Any]]:
        """[UNICODE_6539]"""
        suggestions = []
        
        for analysis in theme_analyses[:10]:  # [UNICODE_4E0A]10[UNICODE_30C6]
            theme = analysis.theme
            
            # [UNICODE_57FA]
            base_suggestions = self.improvement_templates.get(theme, [
                f"{theme}[UNICODE_306B]"
            ])
            
            # [UNICODE_611F]
            if analysis.sentiment_score <= -0.5:
                urgency = "[UNICODE_9AD8]"
                impact = "[UNICODE_30E6]"
            elif analysis.sentiment_score <= -0.2:
                urgency = "[UNICODE_4E2D]"
                impact = "[UNICODE_30E6]"
            else:
                urgency = "[UNICODE_4F4E]"
                impact = "[UNICODE_7D99]"
            
            # [UNICODE_63D0]
            for suggestion_text in base_suggestions:
                suggestion = {
                    "theme": theme,
                    "suggestion": suggestion_text,
                    "urgency": urgency,
                    "impact": impact,
                    "affected_users": analysis.user_count,
                    "frequency": analysis.frequency,
                    "sentiment_score": analysis.sentiment_score,
                    "related_keywords": analysis.related_keywords,
                    "generated_at": datetime.now().isoformat()
                }
                suggestions.append(suggestion)
        
        return suggestions
    
    def get_feedback_statistics(self, days: int = 30) -> Dict[str, Any]:
        """[UNICODE_30D5]"""
        cutoff_date = datetime.now() - timedelta(days=days)
        recent_feedback = [
            fb for fb in self.feedback_items
            if fb.created_at >= cutoff_date
        ]
        
        if not recent_feedback:
            return {
                "total_feedback": 0,
                "period_days": days,
                "statistics": {}
            }
        
        # [UNICODE_57FA]
        total_feedback = len(recent_feedback)
        unique_users = len(set(fb.user_id for fb in recent_feedback))
        
        # [UNICODE_30AB]
        category_dist = Counter(fb.category.value for fb in recent_feedback)
        
        # [UNICODE_512A]
        priority_dist = Counter(fb.priority.value for fb in recent_feedback)
        
        # [UNICODE_8A55]
        ratings = [fb.rating for fb in recent_feedback if fb.rating is not None]
        rating_dist = Counter(ratings) if ratings else {}
        avg_rating = statistics.mean(ratings) if ratings else None
        
        # [UNICODE_611F]
        sentiment_scores = [
            fb.sentiment_analysis.overall_score
            for fb in recent_feedback
            if fb.sentiment_analysis
        ]
        avg_sentiment = statistics.mean(sentiment_scores) if sentiment_scores else None
        
        sentiment_types = [
            fb.sentiment_analysis.sentiment_type.value
            for fb in recent_feedback
            if fb.sentiment_analysis
        ]
        sentiment_dist = Counter(sentiment_types)
        
        # [UNICODE_51E6]
        status_dist = Counter(fb.status for fb in recent_feedback)
        processed_count = len([fb for fb in recent_feedback if fb.processed])
        processing_rate = processed_count / total_feedback if total_feedback > 0 else 0
        
        return {
            "total_feedback": total_feedback,
            "unique_users": unique_users,
            "period_days": days,
            "statistics": {
                "category_distribution": dict(category_dist),
                "priority_distribution": dict(priority_dist),
                "rating_distribution": dict(rating_dist),
                "average_rating": avg_rating,
                "sentiment_distribution": dict(sentiment_dist),
                "average_sentiment": avg_sentiment,
                "status_distribution": dict(status_dist),
                "processing_rate": processing_rate
            }
        }
    
    def get_feedback_by_user(self, user_id: str) -> List[FeedbackItem]:
        """[UNICODE_30E6]"""
        return [fb for fb in self.feedback_items if fb.user_id == user_id]
    
    def get_feedback_by_category(self, category: FeedbackCategory) -> List[FeedbackItem]:
        """[UNICODE_30AB]"""
        return [fb for fb in self.feedback_items if fb.category == category]
    
    def get_high_priority_feedback(self) -> List[FeedbackItem]:
        """[UNICODE_9AD8]"""
        return [
            fb for fb in self.feedback_items
            if fb.priority in [FeedbackPriority.HIGH, FeedbackPriority.CRITICAL]
            and fb.status in ["open", "in_progress"]
        ]
    
    async def update_feedback_status(self, feedback_id: str, status: str,
                                   assigned_to: Optional[str] = None,
                                   resolution: Optional[str] = None) -> Optional[FeedbackItem]:
        """[UNICODE_30D5]"""
        for feedback in self.feedback_items:
            if feedback.feedback_id == feedback_id:
                feedback.status = status
                feedback.updated_at = datetime.now()
                
                if assigned_to:
                    feedback.assigned_to = assigned_to
                
                if resolution:
                    feedback.resolution = resolution
                
                logger.info(f"Feedback {feedback_id} status updated to {status}")
                return feedback
        
        return None
    
    def export_feedback_report(self, format: str = "json") -> str:
        """[UNICODE_30D5]"""
        
        # [UNICODE_7D71]
        stats = self.get_feedback_statistics()
        
        # [UNICODE_30C6]
        theme_counts = defaultdict(int)
        for feedback in self.feedback_items:
            for theme in feedback.themes:
                theme_counts[theme] += 1
        
        report_data = {
            "generated_at": datetime.now().isoformat(),
            "summary": stats,
            "theme_analysis": dict(theme_counts),
            "high_priority_items": len(self.get_high_priority_feedback()),
            "recent_feedback": [
                {
                    "feedback_id": fb.feedback_id,
                    "category": fb.category.value,
                    "title": fb.title,
                    "rating": fb.rating,
                    "priority": fb.priority.value,
                    "status": fb.status,
                    "created_at": fb.created_at.isoformat(),
                    "sentiment_score": fb.sentiment_analysis.overall_score if fb.sentiment_analysis else None,
                    "themes": fb.themes
                }
                for fb in sorted(self.feedback_items, key=lambda x: x.created_at, reverse=True)[:50]
            ]
        }
        
        if format == "json":
            return json.dumps(report_data, indent=2, ensure_ascii=False)
        else:
            return json.dumps(report_data, indent=2, ensure_ascii=False)

# [UNICODE_30B0]
feedback_engine = FeedbackAnalysisEngine()