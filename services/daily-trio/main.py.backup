"""
Daily Trio Service - 1[UNICODE_65E5]3[UNICODE_3064]

[UNICODE_30D6]
- ADHD[UNICODE_306E]1[UNICODE_65E5]3[UNICODE_3064]
- AI[UNICODE_304C]
- 3[UNICODE_30BF]3[UNICODE_5206]
"""

from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
from enum import Enum
import logging
import uuid
import asyncio

# [UNICODE_5171]
import sys
import os
sys.path.append(os.path.join(os.path.dirname(__file__), '../../shared'))

app = FastAPI(title="Daily Trio Service", version="1.0.0")
logger = logging.getLogger(__name__)

class TaskPriority(Enum):
    HIGH = "high"      # [UNICODE_6CBB]
    MEDIUM = "medium"  # [UNICODE_7FD2]
    LOW = "low"        # [UNICODE_7DAD]

class TaskCategory(Enum):
    THERAPEUTIC = "therapeutic"  # [UNICODE_6CBB]
    HABIT = "habit"             # [UNICODE_7FD2]
    SOCIAL = "social"           # [UNICODE_793E]
    MAINTENANCE = "maintenance" # [UNICODE_7DAD]

class DailyTrioTask(BaseModel):
    task_id: str
    title: str
    description: str
    category: TaskCategory
    priority: TaskPriority
    estimated_duration: int  # [UNICODE_5206]
    difficulty: int  # 1-5
    xp_reward: int
    therapeutic_focus: str  # "Self-Discipline", "Empathy", etc.
    completion_criteria: str
    micro_rewards: List[str]  # 3[UNICODE_5206]

class UserState(BaseModel):
    user_id: str
    current_state: str  # APATHY, INTEREST, ACTION, CONTINUATION, HABITUATION
    mood_trend: float  # -1.0 to 1.0
    energy_level: int  # 1-5
    available_time: int  # [UNICODE_5206]
    therapeutic_goals: List[str]
    completed_tasks_today: int
    streak_days: int
    adhd_assist_level: float  # 1.0-1.3

class DailyTrioResponse(BaseModel):
    user_id: str
    selected_date: str
    trio_tasks: List[DailyTrioTask]
    selection_reasoning: str
    estimated_total_time: int
    expected_xp: int
    therapeutic_balance: Dict[str, int]

class DailyTrioEngine:
    def __init__(self):
        self.task_pool = self._initialize_task_pool()
        self.selection_weights = {
            "therapeutic_alignment": 0.4,  # [UNICODE_6CBB]
            "user_state_match": 0.3,       # [UNICODE_30E6]
            "difficulty_balance": 0.2,     # [UNICODE_96E3]
            "variety_bonus": 0.1           # [UNICODE_591A]
        }
    
    def _initialize_task_pool(self) -> List[DailyTrioTask]:
        """[UNICODE_30BF]"""
        return [
            # [UNICODE_6CBB]Self-Discipline[UNICODE_FF09]
            DailyTrioTask(
                task_id="therapeutic_001",
                title="[UNICODE_671D]",
                description="5[UNICODE_5206]1[UNICODE_65E5]",
                category=TaskCategory.THERAPEUTIC,
                priority=TaskPriority.HIGH,
                estimated_duration=5,
                difficulty=2,
                xp_reward=30,
                therapeutic_focus="Self-Discipline",
                completion_criteria="5[UNICODE_5206]",
                micro_rewards=["[UNICODE_6DF1]", "[UNICODE_5FC3]", "[UNICODE_96C6]+10"]
            ),
            DailyTrioTask(
                task_id="therapeutic_002",
                title="[UNICODE_611F]",
                description="[UNICODE_4ECA]3[UNICODE_3064]",
                category=TaskCategory.THERAPEUTIC,
                priority=TaskPriority.HIGH,
                estimated_duration=3,
                difficulty=1,
                xp_reward=20,
                therapeutic_focus="Empathy",
                completion_criteria="[UNICODE_611F]3[UNICODE_3064]",
                micro_rewards=["[UNICODE_611F]", "[UNICODE_5171]+5", "[UNICODE_81EA]"]
            ),
            
            # [UNICODE_7FD2]
            DailyTrioTask(
                task_id="habit_001",
                title="[UNICODE_6C34]",
                description="[UNICODE_30B3]1[UNICODE_676F]",
                category=TaskCategory.HABIT,
                priority=TaskPriority.MEDIUM,
                estimated_duration=1,
                difficulty=1,
                xp_reward=10,
                therapeutic_focus="Self-Discipline",
                completion_criteria="[UNICODE_6C34]",
                micro_rewards=["[UNICODE_6C34]", "[UNICODE_4F53]+3", "[UNICODE_7D99]"]
            ),
            DailyTrioTask(
                task_id="habit_002",
                title="[UNICODE_6574]5[UNICODE_5206]",
                description="[UNICODE_30C7]5[UNICODE_5206]",
                category=TaskCategory.HABIT,
                priority=TaskPriority.MEDIUM,
                estimated_duration=5,
                difficulty=2,
                xp_reward=25,
                therapeutic_focus="Self-Discipline",
                completion_criteria="[UNICODE_6574]",
                micro_rewards=["[UNICODE_6574]", "[UNICODE_96C6]+10", "[UNICODE_9054]"]
            ),
            
            # [UNICODE_793E]
            DailyTrioTask(
                task_id="social_001",
                title="[UNICODE_5BB6]",
                description="[UNICODE_5BB6]5[UNICODE_5206]",
                category=TaskCategory.SOCIAL,
                priority=TaskPriority.MEDIUM,
                estimated_duration=5,
                difficulty=3,
                xp_reward=35,
                therapeutic_focus="Communication",
                completion_criteria="[UNICODE_4F1A]",
                micro_rewards=["[UNICODE_30B3]", "[UNICODE_7D46]+15", "[UNICODE_793E]"]
            ),
            DailyTrioTask(
                task_id="social_002",
                title="[UNICODE_5916]",
                description="[UNICODE_660E]",
                category=TaskCategory.SOCIAL,
                priority=TaskPriority.MEDIUM,
                estimated_duration=10,
                difficulty=3,
                xp_reward=40,
                therapeutic_focus="Courage",
                completion_criteria="[UNICODE_6E96]",
                micro_rewards=["[UNICODE_6E96]", "[UNICODE_52C7]+10", "[UNICODE_81EA]"]
            ),
            
            # [UNICODE_7DAD]
            DailyTrioTask(
                task_id="maintenance_001",
                title="[UNICODE_597D]",
                description="[UNICODE_304A]1[UNICODE_66F2]",
                category=TaskCategory.MAINTENANCE,
                priority=TaskPriority.LOW,
                estimated_duration=4,
                difficulty=1,
                xp_reward=15,
                therapeutic_focus="Resilience",
                completion_criteria="[UNICODE_97F3]",
                micro_rewards=["[UNICODE_97F3]", "[UNICODE_30EA]+5", "[UNICODE_6C17]"]
            )
        ]
    
    async def select_daily_trio(self, user_state: UserState) -> DailyTrioResponse:
        """Daily Trio[UNICODE_81EA]"""
        try:
            # 1. [UNICODE_30E6]
            state_analysis = self._analyze_user_state(user_state)
            
            # 2. [UNICODE_5019]
            scored_tasks = self._score_tasks(user_state, state_analysis)
            
            # 3. [UNICODE_6700]3[UNICODE_3064]
            selected_tasks = self._select_optimal_trio(scored_tasks, user_state)
            
            # 4. [UNICODE_9078]
            reasoning = self._generate_selection_reasoning(selected_tasks, user_state)
            
            # 5. [UNICODE_30EC]
            return DailyTrioResponse(
                user_id=user_state.user_id,
                selected_date=datetime.now().strftime("%Y-%m-%d"),
                trio_tasks=selected_tasks,
                selection_reasoning=reasoning,
                estimated_total_time=sum(task.estimated_duration for task in selected_tasks),
                expected_xp=sum(task.xp_reward for task in selected_tasks),
                therapeutic_balance=self._calculate_therapeutic_balance(selected_tasks)
            )
            
        except Exception as e:
            logger.error(f"Daily Trio selection failed for user {user_state.user_id}: {e}")
            raise HTTPException(status_code=500, detail="Daily Trio[UNICODE_9078]")
    
    def _analyze_user_state(self, user_state: UserState) -> Dict[str, Any]:
        """[UNICODE_30E6]"""
        return {
            "energy_category": self._categorize_energy(user_state.energy_level),
            "time_availability": self._categorize_time(user_state.available_time),
            "therapeutic_priority": self._determine_therapeutic_priority(user_state),
            "difficulty_preference": self._calculate_difficulty_preference(user_state),
            "motivation_level": self._assess_motivation(user_state)
        }
    
    def _categorize_energy(self, energy_level: int) -> str:
        """[UNICODE_30A8]"""
        if energy_level >= 4:
            return "high"
        elif energy_level >= 3:
            return "medium"
        else:
            return "low"
    
    def _categorize_time(self, available_time: int) -> str:
        """[UNICODE_5229]"""
        if available_time >= 30:
            return "abundant"
        elif available_time >= 15:
            return "moderate"
        else:
            return "limited"
    
    def _determine_therapeutic_priority(self, user_state: UserState) -> str:
        """[UNICODE_6CBB]"""
        if user_state.current_state in ["APATHY", "INTEREST"]:
            return "engagement"  # [UNICODE_30A8]
        elif user_state.current_state == "ACTION":
            return "momentum"    # [UNICODE_52E2]
        elif user_state.current_state == "CONTINUATION":
            return "consistency" # [UNICODE_4E00]
        else:  # HABITUATION
            return "mastery"     # [UNICODE_7FD2]
    
    def _calculate_difficulty_preference(self, user_state: UserState) -> float:
        """[UNICODE_96E3]"""
        base_difficulty = 2.0
        
        # [UNICODE_30A8]
        energy_modifier = (user_state.energy_level - 3) * 0.3
        
        # [UNICODE_6C17]
        mood_modifier = user_state.mood_trend * 0.5
        
        # [UNICODE_30B9]
        streak_modifier = min(user_state.streak_days * 0.1, 0.5)
        
        return max(1.0, min(5.0, base_difficulty + energy_modifier + mood_modifier + streak_modifier))
    
    def _assess_motivation(self, user_state: UserState) -> float:
        """[UNICODE_30E2]"""
        motivation = 0.5  # [UNICODE_30D9]
        
        # [UNICODE_72B6]
        state_modifiers = {
            "APATHY": -0.3,
            "INTEREST": 0.0,
            "ACTION": 0.2,
            "CONTINUATION": 0.1,
            "HABITUATION": 0.3
        }
        motivation += state_modifiers.get(user_state.current_state, 0.0)
        
        # [UNICODE_6C17]
        motivation += user_state.mood_trend * 0.3
        
        # [UNICODE_30B9]
        if user_state.streak_days > 0:
            motivation += min(user_state.streak_days * 0.05, 0.2)
        
        return max(0.0, min(1.0, motivation))
    
    def _score_tasks(self, user_state: UserState, state_analysis: Dict[str, Any]) -> List[tuple]:
        """[UNICODE_30BF]"""
        scored_tasks = []
        
        for task in self.task_pool:
            score = 0.0
            
            # [UNICODE_6CBB]
            therapeutic_score = self._calculate_therapeutic_alignment(task, user_state)
            score += therapeutic_score * self.selection_weights["therapeutic_alignment"]
            
            # [UNICODE_30E6]
            state_match_score = self._calculate_state_match(task, state_analysis)
            score += state_match_score * self.selection_weights["user_state_match"]
            
            # [UNICODE_96E3]
            difficulty_score = self._calculate_difficulty_balance(task, state_analysis)
            score += difficulty_score * self.selection_weights["difficulty_balance"]
            
            # [UNICODE_591A]
            variety_score = self._calculate_variety_bonus(task, user_state)
            score += variety_score * self.selection_weights["variety_bonus"]
            
            scored_tasks.append((task, score))
        
        return sorted(scored_tasks, key=lambda x: x[1], reverse=True)
    
    def _calculate_therapeutic_alignment(self, task: DailyTrioTask, user_state: UserState) -> float:
        """[UNICODE_6CBB]"""
        if task.therapeutic_focus in user_state.therapeutic_goals:
            return 1.0
        elif task.category == TaskCategory.THERAPEUTIC:
            return 0.8
        else:
            return 0.5
    
    def _calculate_state_match(self, task: DailyTrioTask, state_analysis: Dict[str, Any]) -> float:
        """[UNICODE_72B6]"""
        score = 0.0
        
        # [UNICODE_30A8]
        energy_category = state_analysis["energy_category"]
        if energy_category == "high" and task.difficulty >= 3:
            score += 0.3
        elif energy_category == "medium" and 2 <= task.difficulty <= 3:
            score += 0.3
        elif energy_category == "low" and task.difficulty <= 2:
            score += 0.3
        
        # [UNICODE_6642]
        time_category = state_analysis["time_availability"]
        if time_category == "limited" and task.estimated_duration <= 5:
            score += 0.3
        elif time_category == "moderate" and task.estimated_duration <= 10:
            score += 0.3
        elif time_category == "abundant":
            score += 0.2
        
        # [UNICODE_6CBB]
        therapeutic_priority = state_analysis["therapeutic_priority"]
        if therapeutic_priority == "engagement" and task.category == TaskCategory.THERAPEUTIC:
            score += 0.4
        elif therapeutic_priority == "momentum" and task.priority == TaskPriority.HIGH:
            score += 0.4
        elif therapeutic_priority == "consistency" and task.category == TaskCategory.HABIT:
            score += 0.4
        elif therapeutic_priority == "mastery" and task.difficulty >= 3:
            score += 0.4
        
        return min(1.0, score)
    
    def _calculate_difficulty_balance(self, task: DailyTrioTask, state_analysis: Dict[str, Any]) -> float:
        """[UNICODE_96E3]"""
        preferred_difficulty = state_analysis["difficulty_preference"]
        difficulty_diff = abs(task.difficulty - preferred_difficulty)
        
        # [UNICODE_5DEE]
        return max(0.0, 1.0 - (difficulty_diff / 4.0))
    
    def _calculate_variety_bonus(self, task: DailyTrioTask, user_state: UserState) -> float:
        """[UNICODE_591A]"""
        # [UNICODE_5B9F]
        # [UNICODE_3053]
        return 0.5
    
    def _select_optimal_trio(self, scored_tasks: List[tuple], user_state: UserState) -> List[DailyTrioTask]:
        """[UNICODE_6700]3[UNICODE_3064]"""
        selected = []
        used_categories = set()
        total_time = 0
        max_time = min(user_state.available_time, 30)  # [UNICODE_6700]30[UNICODE_5206]
        
        for task, score in scored_tasks:
            if len(selected) >= 3:
                break
            
            # [UNICODE_6642]
            if total_time + task.estimated_duration > max_time:
                continue
            
            # [UNICODE_30AB]2[UNICODE_3064]
            category_count = sum(1 for t in selected if t.category == task.category)
            if category_count >= 2:
                continue
            
            selected.append(task)
            used_categories.add(task.category)
            total_time += task.estimated_duration
        
        # 3[UNICODE_3064]
        while len(selected) < 3 and total_time < max_time:
            for task, score in scored_tasks:
                if task not in selected and total_time + task.estimated_duration <= max_time:
                    selected.append(task)
                    total_time += task.estimated_duration
                    break
            else:
                break
        
        return selected
    
    def _generate_selection_reasoning(self, selected_tasks: List[DailyTrioTask], user_state: UserState) -> str:
        """[UNICODE_9078]"""
        reasons = []
        
        # [UNICODE_30A8]
        if user_state.energy_level >= 4:
            reasons.append("[UNICODE_9AD8]")
        elif user_state.energy_level <= 2:
            reasons.append("[UNICODE_4F4E]")
        
        # [UNICODE_6CBB]
        therapeutic_tasks = [t for t in selected_tasks if t.category == TaskCategory.THERAPEUTIC]
        if therapeutic_tasks:
            reasons.append(f"[UNICODE_6CBB]{therapeutic_tasks[0].therapeutic_focus}[UNICODE_300D]")
        
        # [UNICODE_6642]
        total_time = sum(task.estimated_duration for task in selected_tasks)
        reasons.append(f"[UNICODE_5229]{user_state.available_time}[UNICODE_5206]{total_time}[UNICODE_5206]")
        
        return "[UNICODE_3001]".join(reasons) + "[UNICODE_3057]"
    
    def _calculate_therapeutic_balance(self, selected_tasks: List[DailyTrioTask]) -> Dict[str, int]:
        """[UNICODE_6CBB]"""
        balance = {}
        for task in selected_tasks:
            focus = task.therapeutic_focus
            balance[focus] = balance.get(focus, 0) + 1
        return balance

# [UNICODE_30B0]
daily_trio_engine = DailyTrioEngine()

# API[UNICODE_30A8]

@app.post("/daily-trio/select", response_model=DailyTrioResponse)
async def select_daily_trio(user_state: UserState):
    """Daily Trio[UNICODE_81EA]"""
    return await daily_trio_engine.select_daily_trio(user_state)

@app.get("/daily-trio/{user_id}")
async def get_daily_trio(user_id: str, date: Optional[str] = None):
    """Daily Trio[UNICODE_53D6]"""
    # [UNICODE_5B9F]Daily Trio[UNICODE_3092]
    # [UNICODE_3053]
    demo_user_state = UserState(
        user_id=user_id,
        current_state="ACTION",
        mood_trend=0.2,
        energy_level=3,
        available_time=20,
        therapeutic_goals=["Self-Discipline", "Communication"],
        completed_tasks_today=1,
        streak_days=5,
        adhd_assist_level=1.1
    )
    
    return await daily_trio_engine.select_daily_trio(demo_user_state)

@app.post("/daily-trio/{user_id}/complete/{task_id}")
async def complete_trio_task(user_id: str, task_id: str):
    """Daily Trio[UNICODE_30BF]"""
    # [UNICODE_5B9F]XP[UNICODE_4ED8]
    return {
        "success": True,
        "task_id": task_id,
        "xp_earned": 30,
        "micro_rewards": ["[UNICODE_9054]", "[UNICODE_7D99]+1"],
        "completion_time": datetime.now().isoformat(),
        "next_task_available": True
    }

@app.get("/daily-trio/{user_id}/progress")
async def get_trio_progress(user_id: str):
    """Daily Trio[UNICODE_9032]"""
    return {
        "user_id": user_id,
        "date": datetime.now().strftime("%Y-%m-%d"),
        "completed_tasks": 2,
        "total_tasks": 3,
        "completion_rate": 0.67,
        "total_xp_earned": 65,
        "estimated_remaining_time": 5,
        "next_task_hint": "[UNICODE_6700]Daily Trio[UNICODE_3092]"
    }

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8008)