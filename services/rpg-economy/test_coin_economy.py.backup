"""
[UNICODE_30B3]

[UNICODE_30BF]
[UNICODE_30A4]
"""

import unittest
import sys
import os
from datetime import datetime

# [UNICODE_30D1]
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))

from main import (
    CoinEconomy, ActionType, DemonRarity, CoinReward
)
from shared.interfaces.core_types import TaskType
from shared.utils.exceptions import ValidationError


class TestCoinEconomy(unittest.TestCase):
    """[UNICODE_30B3]"""
    
    def setUp(self):
        """[UNICODE_30C6]"""
        self.economy = CoinEconomy()
    
    def test_basic_task_completion_reward(self):
        """[UNICODE_57FA]"""
        reward = self.economy.calculate_coin_reward(
            action_type=ActionType.TASK_COMPLETION,
            difficulty=3,
            performance_multiplier=1.0,
            user_total_coins=0,
            task_type=TaskType.ROUTINE
        )
        
        # ROUTINE [UNICODE_30BF]10[UNICODE_30B3]
        # [UNICODE_96E3]3 [UNICODE_00D7] [UNICODE_30D1]1.0 = 30[UNICODE_30B3]
        self.assertEqual(reward.final_amount, 30)
        self.assertEqual(reward.base_amount, 10)
        self.assertEqual(reward.difficulty_multiplier, 3.0)
        self.assertEqual(reward.performance_multiplier, 1.0)
        self.assertEqual(reward.inflation_adjustment, 1.0)
    
    def test_different_task_types_rewards(self):
        """[UNICODE_7570]"""
        test_cases = [
            (TaskType.ROUTINE, 10),
            (TaskType.ONE_SHOT, 15),
            (TaskType.SKILL_UP, 20),
            (TaskType.SOCIAL, 25)
        ]
        
        for task_type, expected_base in test_cases:
            with self.subTest(task_type=task_type):
                reward = self.economy.calculate_coin_reward(
                    action_type=ActionType.TASK_COMPLETION,
                    difficulty=1,
                    performance_multiplier=1.0,
                    user_total_coins=0,
                    task_type=task_type
                )
                self.assertEqual(reward.base_amount, expected_base)
                self.assertEqual(reward.final_amount, expected_base)
    
    def test_demon_defeat_rewards(self):
        """[UNICODE_9B54]"""
        test_cases = [
            (DemonRarity.COMMON, 50),
            (DemonRarity.RARE, 100),
            (DemonRarity.EPIC, 200),
            (DemonRarity.LEGENDARY, 500)
        ]
        
        for rarity, expected_base in test_cases:
            with self.subTest(rarity=rarity):
                reward = self.economy.calculate_coin_reward(
                    action_type=ActionType.DEMON_DEFEAT,
                    difficulty=1,
                    performance_multiplier=1.0,
                    user_total_coins=0,
                    demon_rarity=rarity
                )
                self.assertEqual(reward.base_amount, expected_base)
                self.assertEqual(reward.final_amount, expected_base)
    
    def test_inflation_control(self):
        """[UNICODE_30A4]"""
        test_cases = [
            (0, 1.0),      # [UNICODE_5236]
            (500, 1.0),    # [UNICODE_5236]
            (1000, 0.95),  # 5%[UNICODE_6E1B]
            (5000, 0.9),   # 10%[UNICODE_6E1B]
            (10000, 0.8),  # 20%[UNICODE_6E1B]
            (15000, 0.8)   # 20%[UNICODE_6E1B]
        ]
        
        for total_coins, expected_adjustment in test_cases:
            with self.subTest(total_coins=total_coins):
                adjustment = self.economy.apply_inflation_control(total_coins)
                self.assertEqual(adjustment, expected_adjustment)
    
    def test_inflation_control_in_reward_calculation(self):
        """[UNICODE_5831]"""
        # [UNICODE_9AD8]
        reward_low = self.economy.calculate_coin_reward(
            action_type=ActionType.TASK_COMPLETION,
            difficulty=3,
            performance_multiplier=1.0,
            user_total_coins=0,  # [UNICODE_65B0]
            task_type=TaskType.ROUTINE
        )
        
        reward_high = self.economy.calculate_coin_reward(
            action_type=ActionType.TASK_COMPLETION,
            difficulty=3,
            performance_multiplier=1.0,
            user_total_coins=10000,  # [UNICODE_9AD8]
            task_type=TaskType.ROUTINE
        )
        
        # [UNICODE_9AD8]20%[UNICODE_6E1B]
        self.assertEqual(reward_low.final_amount, 30)
        self.assertEqual(reward_high.final_amount, 24)  # 30 * 0.8
        self.assertEqual(reward_high.inflation_adjustment, 0.8)
    
    def test_performance_multiplier_effects(self):
        """[UNICODE_30D1]"""
        base_reward = self.economy.calculate_coin_reward(
            action_type=ActionType.TASK_COMPLETION,
            difficulty=2,
            performance_multiplier=1.0,
            user_total_coins=0,
            task_type=TaskType.ROUTINE
        )
        
        high_performance_reward = self.economy.calculate_coin_reward(
            action_type=ActionType.TASK_COMPLETION,
            difficulty=2,
            performance_multiplier=1.5,
            user_total_coins=0,
            task_type=TaskType.ROUTINE
        )
        
        low_performance_reward = self.economy.calculate_coin_reward(
            action_type=ActionType.TASK_COMPLETION,
            difficulty=2,
            performance_multiplier=0.8,
            user_total_coins=0,
            task_type=TaskType.ROUTINE
        )
        
        self.assertEqual(base_reward.final_amount, 20)  # 10 * 2 * 1.0
        self.assertEqual(high_performance_reward.final_amount, 30)  # 10 * 2 * 1.5
        self.assertEqual(low_performance_reward.final_amount, 16)  # 10 * 2 * 0.8
    
    def test_task_completion_coins_integration(self):
        """[UNICODE_30BF]"""
        reward = self.economy.calculate_task_completion_coins(
            task_type=TaskType.SKILL_UP,
            difficulty=4,
            mood_coefficient=1.1,
            adhd_assist=1.2,
            user_total_coins=2000
        )
        
        # SKILL_UP: 20[UNICODE_30D9] [UNICODE_00D7] [UNICODE_96E3]4 [UNICODE_00D7] ([UNICODE_6C17]1.1 [UNICODE_00D7] ADHD1.2) [UNICODE_00D7] [UNICODE_30A4]0.95
        expected = int(20 * 4 * 1.1 * 1.2 * 0.95)
        self.assertEqual(reward.final_amount, expected)
        self.assertEqual(reward.action_type, ActionType.TASK_COMPLETION)
    
    def test_demon_defeat_coins_integration(self):
        """[UNICODE_9B54]"""
        reward = self.economy.calculate_demon_defeat_coins(
            demon_rarity=DemonRarity.EPIC,
            battle_performance=1.8,
            user_total_coins=6000
        )
        
        # EPIC: 200[UNICODE_30D9] [UNICODE_00D7] [UNICODE_30D1]1.8 [UNICODE_00D7] [UNICODE_30A4]0.9
        expected = int(200 * 1.8 * 0.9)
        self.assertEqual(reward.final_amount, expected)
        self.assertEqual(reward.action_type, ActionType.DEMON_DEFEAT)
    
    def test_streak_bonus_calculation(self):
        """[UNICODE_30B9]"""
        test_cases = [
            (7, 100),
            (30, 500),
            (100, 2000),
            (150, 2000)  # 100[UNICODE_65E5]
        ]
        
        for streak_days, expected_base in test_cases:
            with self.subTest(streak_days=streak_days):
                reward = self.economy.calculate_coin_reward(
                    action_type=ActionType.STREAK_BONUS,
                    difficulty=1,
                    performance_multiplier=1.0,
                    user_total_coins=0,
                    streak_days=streak_days
                )
                self.assertEqual(reward.base_amount, expected_base)
    
    def test_daily_bonus_calculation(self):
        """[UNICODE_30C7]"""
        reward = self.economy.calculate_coin_reward(
            action_type=ActionType.DAILY_BONUS,
            difficulty=1,
            performance_multiplier=1.0,
            user_total_coins=0
        )
        
        self.assertEqual(reward.base_amount, 30)
        self.assertEqual(reward.final_amount, 30)
    
    def test_economic_status(self):
        """[UNICODE_7D4C]"""
        status = self.economy.get_economic_status(7500)
        
        self.assertEqual(status["total_coins"], 7500)
        self.assertEqual(status["inflation_adjustment"], 0.9)
        self.assertAlmostEqual(status["inflation_reduction_percent"], 10, delta=1)
        self.assertEqual(status["next_threshold"], 10000)
        self.assertEqual(status["coins_to_next_threshold"], 2500)
        self.assertEqual(status["economic_tier"], "comfortable")
    
    def test_economic_tiers(self):
        """[UNICODE_7D4C]"""
        test_cases = [
            (500, "starting"),
            (1500, "stable"),
            (7000, "comfortable"),
            (15000, "wealthy")
        ]
        
        for coins, expected_tier in test_cases:
            with self.subTest(coins=coins):
                status = self.economy.get_economic_status(coins)
                self.assertEqual(status["economic_tier"], expected_tier)
    
    def test_validation_errors(self):
        """[UNICODE_30D0]"""
        # [UNICODE_7121]
        with self.assertRaises(ValidationError):
            self.economy.calculate_coin_reward(
                action_type=ActionType.TASK_COMPLETION,
                difficulty=0,  # [UNICODE_7121]
                performance_multiplier=1.0,
                user_total_coins=0,
                task_type=TaskType.ROUTINE
            )
        
        # [UNICODE_7121]
        with self.assertRaises(ValidationError):
            self.economy.calculate_coin_reward(
                action_type=ActionType.TASK_COMPLETION,
                difficulty=3,
                performance_multiplier=3.0,  # [UNICODE_7BC4]
                user_total_coins=0,
                task_type=TaskType.ROUTINE
            )
        
        # [UNICODE_5FC5]
        with self.assertRaises(ValidationError):
            self.economy.calculate_coin_reward(
                action_type=ActionType.TASK_COMPLETION,
                difficulty=3,
                performance_multiplier=1.0,
                user_total_coins=0
                # task_type [UNICODE_304C]
            )
    
    def test_reward_data_structure(self):
        """[UNICODE_5831]"""
        reward = self.economy.calculate_coin_reward(
            action_type=ActionType.TASK_COMPLETION,
            difficulty=2,
            performance_multiplier=1.2,
            user_total_coins=1500,
            task_type=TaskType.SOCIAL
        )
        
        # [UNICODE_30C7]
        self.assertIsInstance(reward, CoinReward)
        self.assertIsInstance(reward.timestamp, datetime)
        self.assertEqual(reward.action_type, ActionType.TASK_COMPLETION)
        
        # [UNICODE_8A08]
        self.assertEqual(reward.base_amount, 25)  # SOCIAL [UNICODE_30BF]
        self.assertEqual(reward.difficulty_multiplier, 2.0)
        self.assertEqual(reward.performance_multiplier, 1.2)
        self.assertEqual(reward.inflation_adjustment, 0.95)  # 1500[UNICODE_30B3]
        
        expected_final = int(25 * 2 * 1.2 * 0.95)
        self.assertEqual(reward.final_amount, expected_final)


class TestCoinEconomyIntegration(unittest.TestCase):
    """[UNICODE_30B3]"""
    
    def setUp(self):
        """[UNICODE_30C6]"""
        self.economy = CoinEconomy()
    
    def test_complete_user_journey(self):
        """[UNICODE_5B8C]"""
        user_coins = 0
        rewards_history = []
        
        # 1. [UNICODE_521D]
        reward1 = self.economy.calculate_task_completion_coins(
            task_type=TaskType.ROUTINE,
            difficulty=2,
            mood_coefficient=1.0,
            adhd_assist=1.0,
            user_total_coins=user_coins
        )
        user_coins += reward1.final_amount
        rewards_history.append(reward1)
        
        # 2. [UNICODE_30B9]
        reward2 = self.economy.calculate_task_completion_coins(
            task_type=TaskType.SKILL_UP,
            difficulty=3,
            mood_coefficient=1.1,
            adhd_assist=1.2,
            user_total_coins=user_coins
        )
        user_coins += reward2.final_amount
        rewards_history.append(reward2)
        
        # 3. [UNICODE_9B54]
        reward3 = self.economy.calculate_demon_defeat_coins(
            demon_rarity=DemonRarity.RARE,
            battle_performance=1.5,
            user_total_coins=user_coins
        )
        user_coins += reward3.final_amount
        rewards_history.append(reward3)
        
        # 4. [UNICODE_7D4C]
        status = self.economy.get_economic_status(user_coins)
        
        # [UNICODE_7D50]
        self.assertGreater(user_coins, 0)
        self.assertEqual(len(rewards_history), 3)
        self.assertIn("economic_tier", status)
        
        # [UNICODE_5404]
        self.assertEqual(reward1.final_amount, 20)  # 10 * 2 * 1.0 * 1.0
        expected_reward2 = int(20 * 3 * 1.1 * 1.2)  # [UNICODE_30A4]
        self.assertEqual(reward2.final_amount, expected_reward2)
        
        print(f"[UNICODE_30E6]: [UNICODE_7DCF] {user_coins}")
        print(f"[UNICODE_7D4C]: {status['economic_tier']}")
    
    def test_inflation_progression(self):
        """[UNICODE_30A4]"""
        # [UNICODE_6BB5]
        coin_amounts = [0, 1000, 5000, 10000]
        
        for coins in coin_amounts:
            reward = self.economy.calculate_task_completion_coins(
                task_type=TaskType.ROUTINE,
                difficulty=3,
                mood_coefficient=1.0,
                adhd_assist=1.0,
                user_total_coins=coins
            )
            
            status = self.economy.get_economic_status(coins)
            
            print(f"[UNICODE_30B3]: {coins}, [UNICODE_5831]: {reward.final_amount}, "
                  f"[UNICODE_8ABF]: {reward.inflation_adjustment}, "
                  f"[UNICODE_30C6]: {status['economic_tier']}")
        
        # [UNICODE_6700]
        self.assertTrue(True)  # [UNICODE_4E0A]print[UNICODE_3067]


if __name__ == "__main__":
    # [UNICODE_30C6]
    unittest.main(verbosity=2)