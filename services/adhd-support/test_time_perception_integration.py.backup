#!/usr/bin/env python3
"""
ADHD[UNICODE_652F] - [UNICODE_6642]
[UNICODE_30BF]10.2: [UNICODE_6642]

[UNICODE_8981]3.5: 15[UNICODE_5206]
[UNICODE_8981]9.5: [UNICODE_30C7]1[UNICODE_65E5]2[UNICODE_56DE]
"""

import pytest
import asyncio
import sys
import os
from datetime import datetime, timedelta, date
from unittest.mock import AsyncMock, patch

# Add the parent directory to the path to import the main module
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from main import TimePerceptionSupport, DailyBufferManager, LINENotificationService

class TestTimePerceptionSupport:
    """[UNICODE_6642]"""
    
    def setup_method(self):
        """[UNICODE_30C6]"""
        self.user_id = f"test_user_{id(self)}"  # [UNICODE_5404]ID[UNICODE_3092]
        self.time_support = TimePerceptionSupport(self.user_id)
    
    @pytest.mark.asyncio
    async def test_start_time_perception_reminders(self):
        """15[UNICODE_5206]"""
        task_name = "[UNICODE_30D7]"
        config = {"enabled": True, "interval": 15}
        
        result = await self.time_support.start_time_perception_reminders(task_name, config)
        
        assert result["user_id"] == self.user_id
        assert result["task_name"] == task_name
        assert result["is_active"] == True
        assert result["reminder_count"] == 0
        assert "reminder_id" in result
        assert "start_time" in result
        assert "next_reminder" in result
    
    @pytest.mark.asyncio
    async def test_trigger_reminder_first_time(self):
        """[UNICODE_521D]"""
        task_name = "[UNICODE_8AAD]"
        
        # [UNICODE_30EA]
        reminder_data = await self.time_support.start_time_perception_reminders(task_name)
        reminder_id = reminder_data["reminder_id"]
        
        # 15[UNICODE_5206]
        self.time_support.active_reminders[reminder_id]["next_reminder"] = datetime.utcnow() - timedelta(minutes=1)
        
        # [UNICODE_30EA]
        result = await self.time_support.trigger_reminder(reminder_id)
        
        assert result["reminder_triggered"] == True
        assert result["task_name"] == task_name
        assert result["reminder_count"] == 1
        assert result["elapsed_minutes"] >= 0
        assert "[UNICODE_23F0] 15[UNICODE_5206]" in result["message"]
    
    @pytest.mark.asyncio
    async def test_trigger_reminder_multiple_times(self):
        """[UNICODE_8907]"""
        task_name = "[UNICODE_8CC7]"
        
        # [UNICODE_30EA]
        reminder_data = await self.time_support.start_time_perception_reminders(task_name)
        reminder_id = reminder_data["reminder_id"]
        
        # [UNICODE_8907]
        for i in range(1, 5):  # 1[UNICODE_6642]4[UNICODE_56DE]
            # [UNICODE_6642]
            elapsed_time = i * 15
            self.time_support.active_reminders[reminder_id]["start_time"] = datetime.utcnow() - timedelta(minutes=elapsed_time)
            self.time_support.active_reminders[reminder_id]["next_reminder"] = datetime.utcnow() - timedelta(minutes=1)
            
            result = await self.time_support.trigger_reminder(reminder_id)
            
            assert result["reminder_triggered"] == True
            assert result["reminder_count"] == i
            assert result["elapsed_minutes"] == elapsed_time
            
            # [UNICODE_30E1]
            if elapsed_time <= 15:
                assert "15[UNICODE_5206]" in result["message"]
            elif elapsed_time <= 30:
                assert f"{elapsed_time}[UNICODE_5206]" in result["message"]
                assert "[UNICODE_9806]" in result["message"]
            elif elapsed_time <= 60:
                assert "[UNICODE_4F11]" in result["message"]
    
    @pytest.mark.asyncio
    async def test_pause_and_resume_reminders(self):
        """[UNICODE_30EA]"""
        task_name = "[UNICODE_4F01]"
        
        # [UNICODE_30EA]
        reminder_data = await self.time_support.start_time_perception_reminders(task_name)
        reminder_id = reminder_data["reminder_id"]
        
        # [UNICODE_4E00]
        pause_result = await self.time_support.pause_reminders(reminder_id)
        assert pause_result["paused"] == True
        assert pause_result["reminder_id"] == reminder_id
        
        # [UNICODE_4E00]
        assert self.time_support.active_reminders[reminder_id]["is_active"] == False
        
        # [UNICODE_518D]
        resume_result = await self.time_support.resume_reminders(reminder_id)
        assert resume_result["resumed"] == True
        assert resume_result["reminder_id"] == reminder_id
        
        # [UNICODE_518D]
        assert self.time_support.active_reminders[reminder_id]["is_active"] == True
    
    @pytest.mark.asyncio
    async def test_stop_reminders(self):
        """[UNICODE_30EA]"""
        task_name = "[UNICODE_30E1]"
        
        # [UNICODE_30EA]
        reminder_data = await self.time_support.start_time_perception_reminders(task_name)
        reminder_id = reminder_data["reminder_id"]
        
        # [UNICODE_505C]
        stop_result = await self.time_support.stop_reminders(reminder_id)
        
        assert stop_result["stopped"] == True
        assert stop_result["reminder_id"] == reminder_id
        assert stop_result["total_time_minutes"] >= 0
        assert stop_result["total_reminders"] == 0
        
        # [UNICODE_505C]active_reminders[UNICODE_304B]
        assert reminder_id not in self.time_support.active_reminders

class TestDailyBufferManager:
    """[UNICODE_30C7]"""
    
    def setup_method(self):
        """[UNICODE_30C6]"""
        self.user_id = f"test_user_{id(self)}"  # [UNICODE_5404]ID[UNICODE_3092]
        self.buffer_manager = DailyBufferManager(self.user_id)
    
    @pytest.mark.asyncio
    async def test_get_daily_buffer_status_initial(self):
        """[UNICODE_521D]"""
        status = await self.buffer_manager.get_daily_buffer_status()
        
        assert status["user_id"] == self.user_id
        assert status["extensions_used"] == 0
        assert status["extensions_available"] == 2  # 1[UNICODE_65E5]2[UNICODE_56DE]
        assert status["reset_date"] == date.today()
        assert "extension_history" in status
    
    @pytest.mark.asyncio
    async def test_request_extension_success(self):
        """[UNICODE_671F]"""
        task_id = "task_123"
        hours = 3
        reason = "[UNICODE_4E88]"
        
        result = await self.buffer_manager.request_extension(task_id, hours, reason)
        
        assert result["granted"] == True
        assert result["task_id"] == task_id
        assert result["extension_hours"] == hours
        assert result["extensions_remaining"] == 1  # 2[UNICODE_56DE]1[UNICODE_56DE]
        assert "new_due_date" in result
        assert "[UNICODE_671F]3[UNICODE_6642]" in result["message"]
    
    @pytest.mark.asyncio
    async def test_request_extension_limit_exceeded(self):
        """[UNICODE_671F]"""
        task_id_1 = "task_001"
        task_id_2 = "task_002"
        task_id_3 = "task_003"
        
        # 1[UNICODE_56DE]
        result1 = await self.buffer_manager.request_extension(task_id_1)
        assert result1["granted"] == True
        assert result1["extensions_remaining"] == 1
        
        # 2[UNICODE_56DE]
        result2 = await self.buffer_manager.request_extension(task_id_2)
        assert result2["granted"] == True
        assert result2["extensions_remaining"] == 0
        
        # 3[UNICODE_56DE] - [UNICODE_4E0A]
        result3 = await self.buffer_manager.request_extension(task_id_3)
        assert result3["granted"] == False
        assert result3["reason"] == "daily_limit_exceeded"
        assert result3["extensions_remaining"] == 0
        assert "[UNICODE_4E0A]" in result3["message"]
    
    @pytest.mark.asyncio
    async def test_get_extension_history(self):
        """[UNICODE_5EF6]"""
        # [UNICODE_8907]
        await self.buffer_manager.request_extension("task_A", 2, "[UNICODE_7406]A")
        await self.buffer_manager.request_extension("task_B", 1, "[UNICODE_7406]B")
        
        # [UNICODE_5C65]
        history = await self.buffer_manager.get_extension_history(days=7)
        
        assert len(history) == 2
        assert history[0]["task_id"] in ["task_A", "task_B"]
        assert history[1]["task_id"] in ["task_A", "task_B"]
        
        # [UNICODE_5C65]
        assert history[0]["granted_at"] >= history[1]["granted_at"]
    
    @pytest.mark.asyncio
    async def test_check_extension_eligibility(self):
        """[UNICODE_5EF6]"""
        task_id = "task_eligibility_test"
        
        # [UNICODE_521D]
        eligibility1 = await self.buffer_manager.check_extension_eligibility(task_id)
        assert eligibility1["eligible"] == True
        assert eligibility1["extensions_remaining"] == 2
        assert eligibility1["task_extended_today"] == False
        
        # 1[UNICODE_56DE]
        await self.buffer_manager.request_extension(task_id)
        eligibility2 = await self.buffer_manager.check_extension_eligibility(task_id)
        assert eligibility2["eligible"] == True
        assert eligibility2["extensions_remaining"] == 1
        assert eligibility2["task_extended_today"] == True
        assert eligibility2["task_extension_count"] == 1
    
    @pytest.mark.asyncio
    async def test_reset_daily_buffer(self):
        """[UNICODE_30C7]"""
        # [UNICODE_5EF6]
        await self.buffer_manager.request_extension("task_before_reset")
        
        # [UNICODE_30EA]
        status_before = await self.buffer_manager.get_daily_buffer_status()
        assert status_before["extensions_used"] == 1
        
        # [UNICODE_30EA]
        reset_result = await self.buffer_manager.reset_daily_buffer()
        
        assert reset_result["extensions_used"] == 0
        assert reset_result["extensions_available"] == 2
        assert reset_result["reset_date"] == date.today()
        
        # [UNICODE_30EA]
        status_after = await self.buffer_manager.get_daily_buffer_status()
        assert status_after["extensions_used"] == 0
        assert status_after["extensions_available"] == 2

class TestLINENotificationService:
    """LINE[UNICODE_901A]"""
    
    def setup_method(self):
        """[UNICODE_30C6]"""
        self.notification_service = LINENotificationService()
        self.user_id = "test_user_789"
    
    @pytest.mark.asyncio
    async def test_send_15_minute_reminder_basic(self):
        """[UNICODE_57FA]15[UNICODE_5206]"""
        task_name = "[UNICODE_30C7]"
        elapsed_minutes = 15
        reminder_count = 1
        
        # [UNICODE_30E2]
        with patch.object(self.notification_service, 'send_message', new_callable=AsyncMock) as mock_send:
            await self.notification_service.send_15_minute_reminder(
                self.user_id, task_name, elapsed_minutes, reminder_count
            )
            
            mock_send.assert_called_once()
            args, kwargs = mock_send.call_args
            assert args[0] == self.user_id
            assert "15[UNICODE_5206]" in args[1]
            assert task_name in args[1]
    
    @pytest.mark.asyncio
    async def test_send_15_minute_reminder_long_duration(self):
        """[UNICODE_9577]"""
        task_name = "[UNICODE_30B7]"
        elapsed_minutes = 75  # 1[UNICODE_6642]15[UNICODE_5206]
        reminder_count = 5
        
        with patch.object(self.notification_service, 'send_message', new_callable=AsyncMock) as mock_send:
            await self.notification_service.send_15_minute_reminder(
                self.user_id, task_name, elapsed_minutes, reminder_count
            )
            
            mock_send.assert_called_once()
            args, kwargs = mock_send.call_args
            assert "1[UNICODE_6642]15[UNICODE_5206]" in args[1]
            assert "[UNICODE_4F11]" in args[1]
    
    @pytest.mark.asyncio
    async def test_send_daily_buffer_notification_extension_granted(self):
        """[UNICODE_5EF6]"""
        notification_data = {
            "task_id": "[UNICODE_91CD]",
            "hours": 3,
            "remaining": 1
        }
        
        with patch.object(self.notification_service, 'send_message', new_callable=AsyncMock) as mock_send:
            await self.notification_service.send_daily_buffer_notification(
                self.user_id, "extension_granted", notification_data
            )
            
            mock_send.assert_called_once()
            args, kwargs = mock_send.call_args
            assert "[UNICODE_671F]" in args[1]
            assert "[UNICODE_91CD]" in args[1]
            assert "3[UNICODE_6642]" in args[1]
            assert "[UNICODE_6B8B]: 1[UNICODE_56DE]" in args[1]
    
    @pytest.mark.asyncio
    async def test_send_daily_buffer_notification_extension_denied(self):
        """[UNICODE_5EF6]"""
        notification_data = {"reason": "daily_limit_exceeded"}
        
        with patch.object(self.notification_service, 'send_message', new_callable=AsyncMock) as mock_send:
            await self.notification_service.send_daily_buffer_notification(
                self.user_id, "extension_denied", notification_data
            )
            
            mock_send.assert_called_once()
            args, kwargs = mock_send.call_args
            assert "[UNICODE_671F]" in args[1]
            assert "[UNICODE_4E0A]" in args[1]

class TestIntegration:
    """[UNICODE_7D71]"""
    
    def setup_method(self):
        """[UNICODE_30C6]"""
        self.user_id = f"integration_test_user_{id(self)}"  # [UNICODE_5404]ID[UNICODE_3092]
        self.time_support = TimePerceptionSupport(self.user_id)
        self.buffer_manager = DailyBufferManager(self.user_id)
    
    @pytest.mark.asyncio
    async def test_full_time_perception_workflow(self):
        """[UNICODE_6642]"""
        task_name = "[UNICODE_30D7]"
        
        # 1. [UNICODE_30EA]
        reminder_data = await self.time_support.start_time_perception_reminders(task_name)
        reminder_id = reminder_data["reminder_id"]
        
        # 2. [UNICODE_8907]
        for i in range(1, 4):
            # [UNICODE_6642]
            elapsed_minutes = i * 15
            self.time_support.active_reminders[reminder_id]["start_time"] = datetime.utcnow() - timedelta(minutes=elapsed_minutes)
            self.time_support.active_reminders[reminder_id]["next_reminder"] = datetime.utcnow() - timedelta(minutes=1)
            
            result = await self.time_support.trigger_reminder(reminder_id)
            assert result["reminder_triggered"] == True
            assert result["elapsed_minutes"] == elapsed_minutes
        
        # 3. [UNICODE_4E00]
        pause_result = await self.time_support.pause_reminders(reminder_id)
        assert pause_result["paused"] == True
        
        # 4. [UNICODE_518D]
        resume_result = await self.time_support.resume_reminders(reminder_id)
        assert resume_result["resumed"] == True
        
        # 5. [UNICODE_505C]
        stop_result = await self.time_support.stop_reminders(reminder_id)
        assert stop_result["stopped"] == True
    
    @pytest.mark.asyncio
    async def test_full_daily_buffer_workflow(self):
        """[UNICODE_30C7]"""
        # 1. [UNICODE_521D]
        initial_status = await self.buffer_manager.get_daily_buffer_status()
        assert initial_status["extensions_available"] == 2
        
        # 2. 1[UNICODE_56DE]
        result1 = await self.buffer_manager.request_extension("task_1", 2, "[UNICODE_4E88]")
        assert result1["granted"] == True
        assert result1["extensions_remaining"] == 1
        
        # 3. 2[UNICODE_56DE]
        result2 = await self.buffer_manager.request_extension("task_2", 1, "[UNICODE_8FFD]")
        assert result2["granted"] == True
        assert result2["extensions_remaining"] == 0
        
        # 4. 3[UNICODE_56DE]
        result3 = await self.buffer_manager.request_extension("task_3", 1, "[UNICODE_3055]")
        assert result3["granted"] == False
        assert result3["reason"] == "daily_limit_exceeded"
        
        # 5. [UNICODE_5C65]
        history = await self.buffer_manager.get_extension_history()
        assert len(history) == 2
        
        # 6. [UNICODE_30EA]
        reset_result = await self.buffer_manager.reset_daily_buffer()
        assert reset_result["extensions_available"] == 2
        
        # 7. [UNICODE_30EA]
        result4 = await self.buffer_manager.request_extension("task_4", 1, "[UNICODE_30EA]")
        assert result4["granted"] == True

def run_tests():
    """[UNICODE_30C6]"""
    print("[UNICODE_1F9EA] ADHD[UNICODE_652F] - [UNICODE_6642]...")
    
    # pytest[UNICODE_5B9F]
    exit_code = pytest.main([
        __file__,
        "-v",
        "--tb=short"
    ])
    
    if exit_code == 0:
        print("[UNICODE_2705] [UNICODE_3059]")
        print("\n[UNICODE_1F4CB] [UNICODE_5B9F]:")
        print("  - 15[UNICODE_5206]")
        print("  - [UNICODE_30EA]")
        print("  - [UNICODE_30C7]1[UNICODE_65E5]2[UNICODE_56DE]")
        print("  - [UNICODE_5EF6]")
        print("  - [UNICODE_5EF6]")
        print("  - LINE[UNICODE_901A]")
        print("  - [UNICODE_6642]")
    else:
        print("[UNICODE_274C] [UNICODE_30C6]")
    
    return exit_code == 0

if __name__ == "__main__":
    success = run_tests()
    exit(0 if success else 1)