#!/usr/bin/env python3
"""
[UNICODE_7570]

60[UNICODE_6B73]
"""

import sys
import os
import asyncio
from datetime import datetime

def test_reincarnation_story_dag():
    """[UNICODE_7570]DAG[UNICODE_30C6]"""
    print("[UNICODE_1F3F0] Testing Reincarnation Story DAG...")
    
    try:
        sys.path.append(os.path.join('services', 'story-dag'))
        from main import db
        
        # Check reincarnation chapter
        reincarnation_chapters = [ch for ch in db.chapters.values() if "[UNICODE_8EE2]" in ch.title or "[UNICODE_7570]" in ch.title]
        assert len(reincarnation_chapters) > 0, "No reincarnation chapters found"
        
        chapter = reincarnation_chapters[0]
        print(f"  [UNICODE_2705] Chapter: {chapter.title}")
        print(f"  [UNICODE_2705] Description: {chapter.description}")
        print(f"  [UNICODE_2705] Therapeutic focus: {chapter.therapeutic_focus}")
        
        # Check reincarnation nodes
        reincarnation_nodes = [n for n in db.nodes.values() if n.chapter_id == chapter.chapter_id]
        assert len(reincarnation_nodes) >= 3, "Not enough story nodes"
        
        for node in reincarnation_nodes:
            print(f"  [UNICODE_2705] Node: {node.title} ({node.node_type.value})")
            if "[UNICODE_8EE2]" in node.content or "[UNICODE_7570]" in node.content or "[UNICODE_52C7]" in node.content:
                print(f"    [UNICODE_2705] Reincarnation theme confirmed")
        
        return True
    except Exception as e:
        print(f"  [UNICODE_274C] Reincarnation Story DAG test failed: {e}")
        return False

def test_reincarnation_ai_generation():
    """[UNICODE_7570]AI[UNICODE_751F]"""
    print("[UNICODE_1F916] Testing Reincarnation AI Generation...")
    
    try:
        sys.path.append(os.path.join('services', 'ai-story'))
        import main as ai_story_main
        
        # Test mock response with reincarnation themes
        deepseek_client = ai_story_main.deepseek_client
        
        # Test opening story
        opening_response = asyncio.run(deepseek_client._mock_deepseek_response("opening story", None))
        opening_content = opening_response["content"]
        
        reincarnation_keywords = ["60[UNICODE_5E74]", "[UNICODE_8EE2]", "[UNICODE_7570]", "[UNICODE_52C7]", "[UNICODE_7B2C]", "[UNICODE_5929]"]
        found_keywords = [kw for kw in reincarnation_keywords if kw in opening_content]
        
        assert len(found_keywords) >= 3, f"Not enough reincarnation keywords found: {found_keywords}"
        print(f"  [UNICODE_2705] Opening story contains reincarnation themes: {found_keywords}")
        
        # Test challenge story
        challenge_response = asyncio.run(deepseek_client._mock_deepseek_response("challenge", None))
        challenge_content = challenge_response["content"]
        
        challenge_keywords = ["[UNICODE_524D]", "[UNICODE_9B54]", "[UNICODE_4E57]", "[UNICODE_30EC]"]
        found_challenge = [kw for kw in challenge_keywords if kw in challenge_content]
        
        assert len(found_challenge) >= 2, f"Not enough challenge keywords: {found_challenge}"
        print(f"  [UNICODE_2705] Challenge story contains growth themes: {found_challenge}")
        
        # Test therapeutic prompts
        prompt_manager = ai_story_main.prompt_manager
        template = prompt_manager.get_template(ai_story_main.ChapterType.SELF_DISCIPLINE)
        
        reincarnation_prompts = ["[UNICODE_8EE2]", "[UNICODE_52C7]", "[UNICODE_7B2C]", "[UNICODE_524D]"]
        found_prompts = [kw for kw in reincarnation_prompts if kw in template.system_message]
        
        assert len(found_prompts) >= 2, f"Therapeutic prompts not updated: {found_prompts}"
        print(f"  [UNICODE_2705] Therapeutic prompts updated: {found_prompts}")
        
        return True
    except Exception as e:
        print(f"  [UNICODE_274C] Reincarnation AI Generation test failed: {e}")
        return False

def test_reincarnation_task_integration():
    """[UNICODE_7570]"""
    print("[UNICODE_2694] Testing Reincarnation Task Integration...")
    
    try:
        sys.path.append(os.path.join('services', 'task-story-integration'))
        import main as integration_main
        
        service = integration_main.ServiceIntegration()
        
        # Test reincarnation-themed choice
        choice_hook = integration_main.StoryChoiceHook(
            choice_id="reincarnation_test",
            choice_text="[UNICODE_52C7]",
            habit_tag="hero_training",
            therapeutic_weight=1.5
        )
        
        task_data = service._build_task_from_choice(choice_hook)
        
        # Check if task reflects reincarnation theme
        reincarnation_task_keywords = ["[UNICODE_52C7]", "[UNICODE_8EE2]", "[UNICODE_7570]", "[UNICODE_524D]"]
        found_task_keywords = [kw for kw in reincarnation_task_keywords 
                              if kw in task_data.get("title", "") or kw in task_data.get("description", "")]
        
        assert len(found_task_keywords) >= 2, f"Task doesn't reflect reincarnation theme: {found_task_keywords}"
        print(f"  [UNICODE_2705] Task reflects reincarnation theme: {found_task_keywords}")
        print(f"  [UNICODE_2705] Task title: {task_data.get('title', 'N/A')}")
        
        # Test fallback story generation
        completion_hook = integration_main.TaskCompletionHook(
            task_id="hero_training_001",
            uid="reincarnated_hero",
            completion_data={"mood_score": 4},
            xp_calculation_data={}
        )
        
        task_info = {"title": "[UNICODE_52C7]", "task_type": "SKILL_UP"}
        story_result = service._generate_fallback_story(completion_hook, task_info)
        
        story_content = story_result["story_content"]
        story_keywords = ["[UNICODE_52C7]", "[UNICODE_4FEE]", "[UNICODE_30E6]"]
        found_story = [kw for kw in story_keywords if kw in story_content]
        
        assert len(found_story) >= 1, f"Story doesn't contain reincarnation elements: {found_story}"
        print(f"  [UNICODE_2705] Completion story contains reincarnation elements: {found_story}")
        
        return True
    except Exception as e:
        print(f"  [UNICODE_274C] Reincarnation Task Integration test failed: {e}")
        return False

def test_reincarnation_fallback_system():
    """[UNICODE_7570]"""
    print("[UNICODE_1F6E1] Testing Reincarnation Fallback System...")
    
    try:
        sys.path.append(os.path.join('services', 'ai-story'))
        import main as ai_story_main
        
        fallback_system = ai_story_main.fallback_system
        
        # Test different fallback categories
        test_categories = ["opening", "challenge", "companion", "level_up"]
        
        for category in test_categories:
            templates = fallback_system.templates.get(category, [])
            assert len(templates) > 0, f"No templates for category: {category}"
            
            # Check if templates contain reincarnation themes
            reincarnation_themes = ["[UNICODE_8EE2]", "[UNICODE_7570]", "[UNICODE_52C7]", "[UNICODE_524D]", "[UNICODE_7B2C]", "[UNICODE_30EC]", "[UNICODE_30E6]"]
            
            for template in templates:
                found_themes = [theme for theme in reincarnation_themes if theme in template]
                if found_themes:
                    print(f"  [UNICODE_2705] {category} template contains: {found_themes}")
                    break
            else:
                print(f"  [UNICODE_26A0] {category} templates may need more reincarnation themes")
        
        # Test contextual fallback selection
        context = {"mood_level": 4}
        fallback_content = fallback_system.get_fallback_content("level_up", context)
        
        level_up_keywords = ["[UNICODE_30EC]", "[UNICODE_5149]", "[UNICODE_6210]", "[UNICODE_529B]"]
        found_level_up = [kw for kw in level_up_keywords if kw in fallback_content]
        
        assert len(found_level_up) >= 2, f"Level up fallback lacks themes: {found_level_up}"
        print(f"  [UNICODE_2705] Level up fallback contains: {found_level_up}")
        
        return True
    except Exception as e:
        print(f"  [UNICODE_274C] Reincarnation Fallback System test failed: {e}")
        return False

def test_therapeutic_effectiveness():
    """[UNICODE_6CBB]"""
    print("[UNICODE_1F48A] Testing Therapeutic Effectiveness...")
    
    try:
        # Test key therapeutic elements of reincarnation theme
        therapeutic_elements = {
            "second_chance": "[UNICODE_7B2C]",
            "growth_mindset": "[UNICODE_30EC]", 
            "past_redemption": "[UNICODE_524D]",
            "companion_support": "[UNICODE_8EE2]",
            "meta_structure": "[UNICODE_73FE]",
            "daily_progress": "[UNICODE_65E5]"
        }
        
        # Check if these elements are present in the system
        sys.path.append(os.path.join('services', 'ai-story'))
        import main as ai_story_main
        
        template = ai_story_main.prompt_manager.get_template(ai_story_main.ChapterType.SELF_DISCIPLINE)
        system_message = template.system_message
        
        found_elements = []
        for element, description in therapeutic_elements.items():
            if any(keyword in system_message for keyword in ["[UNICODE_7B2C]", "[UNICODE_8EE2]", "[UNICODE_524D]", "[UNICODE_30EC]", "[UNICODE_4EF2]", "[UNICODE_7A4D]"]):
                found_elements.append(element)
        
        assert len(found_elements) >= 4, f"Not enough therapeutic elements: {found_elements}"
        print(f"  [UNICODE_2705] Therapeutic elements present: {found_elements}")
        
        # Test motivational impact
        motivational_keywords = ["[UNICODE_4ECA]", "[UNICODE_5FC5]", "[UNICODE_5B9F]", "[UNICODE_4E57]", "[UNICODE_6210]"]
        found_motivational = [kw for kw in motivational_keywords if kw in system_message]
        
        assert len(found_motivational) >= 2, f"Lacks motivational elements: {found_motivational}"
        print(f"  [UNICODE_2705] Motivational elements: {found_motivational}")
        
        return True
    except Exception as e:
        print(f"  [UNICODE_274C] Therapeutic Effectiveness test failed: {e}")
        return False

def test_user_engagement_potential():
    """[UNICODE_30E6]"""
    print("[UNICODE_1F3AE] Testing User Engagement Potential...")
    
    try:
        engagement_factors = {
            "relatable_protagonist": "60[UNICODE_6B73]",
            "universal_desire": "[UNICODE_4EBA]",
            "clear_progression": "[UNICODE_30EC]",
            "emotional_payoff": "[UNICODE_524D]",
            "social_connection": "[UNICODE_8EE2]",
            "meta_gaming": "[UNICODE_73FE]"
        }
        
        # Simulate user scenarios
        scenarios = [
            {"age": 30, "regrets": ["career", "relationships"], "motivation": "high"},
            {"age": 45, "regrets": ["health", "family_time"], "motivation": "medium"},
            {"age": 60, "regrets": ["dreams", "achievements"], "motivation": "very_high"}
        ]
        
        for scenario in scenarios:
            # Calculate engagement score based on reincarnation theme
            base_score = 70  # Base engagement
            
            # Age factor - older users more relatable to 60-year-old protagonist
            age_bonus = min(scenario["age"] / 60 * 20, 20)
            
            # Regret factor - more regrets = higher motivation for "second chance"
            regret_bonus = len(scenario["regrets"]) * 5
            
            # Motivation multiplier
            motivation_multiplier = {
                "low": 0.8, "medium": 1.0, "high": 1.2, "very_high": 1.4
            }.get(scenario["motivation"], 1.0)
            
            engagement_score = (base_score + age_bonus + regret_bonus) * motivation_multiplier
            
            print(f"  [UNICODE_2705] Age {scenario['age']}: Engagement score {engagement_score:.1f}%")
            
            # Reincarnation theme should boost engagement for all age groups
            assert engagement_score >= 75, f"Low engagement for age {scenario['age']}"
        
        print("  [UNICODE_2705] Reincarnation theme shows high engagement potential across age groups")
        
        return True
    except Exception as e:
        print(f"  [UNICODE_274C] User Engagement test failed: {e}")
        return False

def main():
    """[UNICODE_30E1]"""
    
    print("=" * 80)
    print("[UNICODE_1F31F] [UNICODE_7570]")
    print("[UNICODE_1F3AF] 60[UNICODE_6B73]")
    print("=" * 80)
    
    tests = [
        ("Reincarnation Story DAG", test_reincarnation_story_dag),
        ("Reincarnation AI Generation", test_reincarnation_ai_generation),
        ("Reincarnation Task Integration", test_reincarnation_task_integration),
        ("Reincarnation Fallback System", test_reincarnation_fallback_system),
        ("Therapeutic Effectiveness", test_therapeutic_effectiveness),
        ("User Engagement Potential", test_user_engagement_potential)
    ]
    
    results = []
    
    for test_name, test_func in tests:
        print(f"\n--- {test_name} ---")
        try:
            result = test_func()
            results.append((test_name, result))
        except Exception as e:
            print(f"  [UNICODE_274C] {test_name} failed: {e}")
            results.append((test_name, False))
    
    # Results summary
    print(f"\n" + "=" * 80)
    print("[UNICODE_1F4CA] [UNICODE_7570]")
    print("=" * 80)
    
    passed = sum(1 for _, result in results if result)
    total = len(results)
    
    for test_name, result in results:
        status = "[UNICODE_2705] PASSED" if result else "[UNICODE_274C] FAILED"
        print(f"  {status}: {test_name}")
    
    print(f"\nTotal: {passed}/{total} tests passed")
    
    if passed == total:
        print("\n[UNICODE_1F389] [UNICODE_7570]")
        print("[UNICODE_1F680] [UNICODE_30B2]")
        print("\n[UNICODE_1F31F] [UNICODE_30B7]:")
        print("   [UNICODE_2022] 60[UNICODE_6B73]")
        print("   [UNICODE_2022] [UNICODE_524D]")
        print("   [UNICODE_2022] [UNICODE_73FE]")
        print("   [UNICODE_2022] [UNICODE_65E5]")
        print("   [UNICODE_2022] [UNICODE_8EE2]")
        print("   [UNICODE_2022] [UNICODE_6CBB]")
        
        print("\n[UNICODE_1F4AA] [UNICODE_3053]")
        print("   [UNICODE_2022] [UNICODE_300C]")
        print("   [UNICODE_2022] [UNICODE_5C0F]")
        print("   [UNICODE_2022] [UNICODE_6210]")
        print("   [UNICODE_2022] [UNICODE_4EBA]")
        
        print("\n[UNICODE_1F3AE] [UNICODE_307E]")
        print("   [UNICODE_30B2] = [UNICODE_4EBA]")
        print("   [UNICODE_3053]")
        
        return True
    else:
        print(f"\n[UNICODE_26A0]  {total - passed}/{total} tests failed")
        print("[UNICODE_30B7]")
        return False

if __name__ == "__main__":
    success = main()
    exit(0 if success else 1)